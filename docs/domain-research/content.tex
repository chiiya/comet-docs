%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\section{Einführung in die Thematik}

Innerhalb dieses einführenden Kapitels in die Thematik werden Grundlagen bezüglich der Bereiche, in denen sich das Projekt bewegt, aufgezeigt. Dies umfasst eine kurze Erläutering der Prinzipien von HTTP und REST, sowie eine Untersuchung der verschiedenen Deskriptionsformate zum Beschreiben von REST APIs.

\subsection{HTTP}

Das \emph{Hypertext Transfer Protocol} (HTTP) ist ein Anwendungsprotokoll zur Kommunikation über ein Netzwerk. HTTP ist das primäre Kommunikationsprotokoll im World Wide Web, und wurde von der Internet Engineering Task Force (IETF) und dem World Wide Web Consortium (W3C) in einer Reihe von RFC-Dokumenten (z.B. \emph{RFC 7230}, \emph{RFC 7231} und \emph{RFC 7540}) standardisiert. Eine HTTP-Nachricht wird in der Regel über TCP übertragen, und besteht aus 4 Komponenten:

\begin{description}
	\item \emph{Verb / Methode}: Operationstyp, der durchgeführt werden soll, beispielsweise das Anfragen einer Ressource.
    \item \emph{Ressourcenpfad}: Ein Bezeichner, der angibt, auf welche Ressource die HTTP-Operation angewendet werden soll.
    \item \emph{Headers}: Zusätzliche Metadaten, ausgedrückt als Liste von Key/Value-Paaren.
    \item \emph{Body}: Nutzdaten der Nachricht.
\end{description}

Das HTTP Protokoll erlaubt die folgenden Operationen bzw. Methoden:

\begin{description}
	\item \emph{GET}: Die angegebene Ressource sollte im Body-Teil der Antwort zurückgegeben werden.
	\item \emph{HEAD}: Wie \emph{GET}, nur dass die Nutzdaten nicht zurückgegeben werden sollen. Dies ist nützlich, wenn nur überprüfen wird, ob eine Ressource existiert, oder wenn nur die Header abgerufen werden sollen.
	\item \emph{POST}: Daten werden an den Server geschickt. Häufig wird diese Methode benutzt, um neue Ressourcen anzulegen.
	\item \emph{DELETE}: Die angegebene Ressource löschen.
	\item \emph{PUT}: Die angegeben Ressource mit neuen Daten ersetzen.
	\item \emph{PATCH}: Ändert eine Ressource, ohne diese vollständig zu ersetzen.
	\item \emph{TRACE}: Liefert die Anfrage so zurück, wie der Server sie empfangen hat.
	\item \emph{OPTIONS}: Liefert eine Liste der vom Server unterstützten Methoden auf einer Ressource.
	\item \emph{CONNECT}: Eine Tunneling-Verbindung über einen HTTP-Proxy herstellen, die normalerweise für verschlüsselte Kommunikationen benötigt wird.
\end{description}

Wenn ein Client eine HTTP-Anfrage sendet, schickt der Server eine HTTP-Antwort mit Headern und möglicherweise Nutzdaten im Body zurück. Darüber hinaus enthält die Antwort auch einen numerischen, dreistelligen Statuscode. Es gibt fünf Gruppen von Statuscodes, die durch die erste Ziffer identifiziert werden können:

\begin{description}
	\item \emph{1xx}: Wird für provisorische Antworten verwendet, wie z.B. der Information, dass die Bearbeitung der Anfrage trotz der Rückmeldung noch andauert.
	\item \emph{2xx}: Wird zurückgegeben, wenn die Anfrage erfolgreich bearbeitet wurde. Der Server könnte beispielsweise weiter spezifizieren, dass eine neue Ressource angelegt wurde (201), z.B. durch einen POST-Befehl, oder dass im Antwortkörper (204) nichts erwartet wird, z.B. durch einen DELETE-Befehl.
	\item \emph{3xx}: Wird wird Umleitungen benutzt. So kann dem Client bspw. mitgeteilt werden, dass sich eine Ressource an einem neuen Ort befindet.
	\item \emph{4xx}: Bei der Bearbeitung der Anfrage ist ein Fehler aufgetreten, der durch den Client verursacht wurde. Dies können beispielsweise falsch formatierte Anfragen (400), Anfragen die vom Server nicht bearbeitet werden können (422), oder auch einfach Anfragen auf nicht existierende Ressourcen (404) sein.
	\item \emph{5xx}: Bei der Bearbeitung der Anfrage ist ein Fehler aufgetreten, dessen Ursache beim Server liegt. 
\end{description}


\subsection{REST}

Representational State Transfer (REST) ist eine Abstraktion der architektonischen Elemente innerhalb eines verteilten Hypermediasystems. Es ist somit ein Softwarearchitekturstil, der die architektonischen Prinzipien, Eigenschaften und Einschränkungen für die Umsetzung von internetbasierten verteilten Systemen definiert \parencite[86]{fielding2000architectural}. REST basiert auf fünf Kernprinzipien \parencite[11]{tilkov2015rest}:
\begin{itemize}
	\item Ressourcen als Abstraktion von Informationen, identifiziert durch einen eindeutigen \emph{resource identifier}
	\item Verknüpfungen / Hypermedia
	\item Standardmethoden
	\item Unterschiedliche Repräsentationen
	\item Statuslose Kommunikation
\end{itemize}

In Folgendem wird untersucht, welche maschinenlesbare Spezifikationsformate zur Beschreibung von auf HTTP basierenden REST APIs zur Verfügung stehen. Ziel dieser Untersuchung ist es, eine abstrakte Modellierung von REST APIs zu konzipieren, die verwendet werden kann, um eine API Spezifikation in eine interne Datenstruktur zu überführen, welche dann anschließend angereichert wird um automatisiert Artefakte wie Dokumentation oder Test-Cases zu generieren. Im Zuge dessen wird ebenfalls analysiert, welche Möglichkeiten in diesem Feld bereits existieren.

\subsection{Spezifikationsformate}

\subsubsection{Contract First und Contract Last}

Es kann im Wesentlichen zwischen zwei verschiedenen Ansätzen zur Definition des Vertrages, den eine API garantiert, unterschieden werden \parencite[272]{spichale2017api}:

\begin{itemize}
	\item \emph{Contract-First}. Bei diesem Ansatz wird zunächst der Vertrag (also die Spezifikation der API) geschrieben, und anschließend die Implementierung. Vorteilhaft ist hier der größere Fokus auf dem Design der Schnittstelle. In frühen Iterationen der Spezifikation kann in Abstimmung mit den Konsumenten der API mit geringen Aufwand der Vertrag gefestigt werden, sodass später bei der Implementierung weniger Änderungen anfallen. Nachteil ist, dass Entwickler mehr mit den eigentlichen Spezifikationen arbeiten müssen, und diese nicht automatisch generieren können.
	\item \emph{Contract-Last}. Bei diesem Ansatz existiert die Implementierung bereits, und die Beschreibung wird nachträglich erzeugt. Häufig können hier unterstützend Tools benutzt werden, welche die Spezifikation automatisch aus der Implementierung generieren, und der Entwickler muss meistens nur noch einige Annotationen anpassen. Da bei der automatischen Generierung Schemas in vielen Fällen dupliziert werden, kann dies zu mehr Aufwand führen, wenn manuelle Anpassungen vorgenommen werden müssen. Ebenso reduziert dies die Wiederverwendbarkeit von Spezifikationsteilen oder Schemas \parencite[1]{zhong2009contract}.
\end{itemize}

Bei beiden Ansätzen müssen Tests angelegt werden, die sicherstellen, dass die Implementierung nicht von der Beschreibung bzw. Dokumentation abweicht.
 
\subsubsection{RAML}
RAML (\emph{RESTful API Modeling Language}) ist ein auf YAML basierende Spezifikationsformat. Es wurde insbesondere für den \emph{Contract-First} Ansatz konzipiert, der Schwerpunkt liegt damit auf dem API-Design \parencites[277]{spichale2017api}[165]{tilkov2015rest}. Beschreibungen können in Markdown formatiert werden. Jedes RAML-Dokument beginnt mit der Angabe der RAML-Version und einigen allgemeinen Informationen zur API, wie Titel, URL und Version. Hier können ebenfalls Strukturierungshilfen wie Traits oder Datentypen definiert werden, welche dann im Rest des Dokumentes eingebunden werden können. Anschließend folgen die Beschreibungen der Ressourcen und Subressourcen. Zur Beschreibung von Requests und Responses können optional die bereits definierten Datentypen oder auch JSON-Schema Definitionen verwendet werden. Über \emph{Includes} kann die Spezifikation in mehrere Dateien aufgeteilt werden.

Folgendes Beispiel wurde aus der RAML-Spezifikation entnommen \parencite{ramlspec}.

\begin{lstlisting}
#%RAML 1.0
title: GitHub API
version: v3
baseUri: https://api.github.com
mediaType:  application/json
securitySchemes:
  oauth_2_0: !include securitySchemes/oauth_2_0.raml
traits:
securedBy: [ oauth_2_0 ]
title: API with Types
types:
  User:
    type: object
    properties:
      firstname: string
      lastname:  string
      age:       number
/users/{id}:
  get:
    responses:
      200:
        body:
          application/json:
            type: User
\end{lstlisting}